# 数据结构

## 一.绪论

### 1.1 数据结构研究

- 数据结构是一门研究非数值计算的程序设计中计算机的操作对象以及它们之间的关系和操作的学科
  - 即“非数值计算”的程序设计问题
  - 非数值计算问题的数学模型不是数学方程，而是表、树、图之类的具有逻辑关系的数据

### 1.2 基本概念和术语

* 数据
  * 数值型数据：可进行算术运算
  * 非数值型数据：不能算数运算，主要是表、图之类的

- 数据元素

  - 数据的基本单位
  - 如在一张学生表中的某一行，包括学生的姓名、学号、性别（这些都是数据项），看作一个，即一个数据元素（也叫元素、记录、结点、顶点）
  - 数据项组成数据元素，数据元素组成数据

- 数据对象

  - 性质相同的数据元素的集合，是数据的一个子集
    - 如整数的数据对象$N=\{0, \pm1,\pm2,...\}$

- 数据结构：数据元素相互之间的关系（是带结构的数据元素的集合，元素之间不是孤立的而是存在某种关系）

  - 逻辑结构

    ​     **划分方式1**

    - 线性结构：有且仅有一个开始结点和一个终端结点
      - 线性表、栈、队列、串
    - 非线性结构
      - 图、树

    ​     **划分方式2**

    * 集合结构
    * 线性结构：一对一
    * 树形结构：一对多
    * 网状结构

  - 物理结构：数据元素在计算机存储器中的结构

    - 顺序存储结构：用一组**连续的存储单元**依次存储数据元素；如C语言中的数组实现顺序存储结，存储顺序与元素顺序相同，
    - 链接存储结构：用一组**任意的存储单元**存储数据元素；之间的逻辑关系用指针来表示，如C语言中的指针实现链式存储结构

  - 数据运算

- 数据类型

- 抽象数据类型

### 1.4 算法复杂度

#### 1.计算方法

**算法运行时间=一个简单操作所需的时间×简单操作次数**

**算法运行时间=Σ每条语句的执行次数×该语句执行一次所需的时间**

- 每条语句的执行次数：语句频度
- 该语句执行一次所需的时间：随机器而已的固定时间，看作单位时间

算法运行时间=Σ每条语句频度×单位时间

消耗时间记为$T(n)$

- 为了便于比较不同算法的时间效率，我们仅比较他们的数量级
- 如$T_1(n)=10n^2, T_2(n)=5n^3$，数量级越大的越不好，所以$T_1(n)$更好

$f(n)$是$T(n)$的数量级函数，$O(f(n))$是算法的时间复杂度

例：如一个算法的时间复杂度为$T(n)=2n^3+3n^2+2n+1$，n无限大时$T(n)$与$n^3$是同数量级，引入O记号，则可记作$T(n)=O(n^3)$

- 只用看幂次最高的项幂次是多少，所以找到算法中执行次数最多的语句执行了多少次即可，找执行循环嵌套最深的

- 要注意，循环体的执行次数会比循环体内语句的执行次数多一次

#### 2.示例

##### 例1

N×N的矩阵相乘

~~~c
for( i = 1, i <= n; i ++ ){
	for( j = 1; j <= n; j ++ ){
		c[i][j] = 0;
		for( k = 1; k <= n; k ++ ){
			c[i][j] = c[i][j] + a[i][k]*b[k][j];
		}
	}
}
~~~

$$
T(n) = \sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n1\\=\sum_{i=1}^n\sum_{j=1}^nn\\=\sum_{i=1}^nn^2=n^3\\=o(n^3)
$$

##### 例2

~~~c
for( i = 1; i <= n; i ++ ){
	for( j = 1; j <= n; j ++ ){
		for( k = 1; k <= n; k ++ ){
			x += 1;
		}
	}
}
~~~

$$
语句频度=\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j1\\
=\sum_{i=1}^n\sum_{j=1}^ij\\
=\sum_{i=1}^n\frac{i(i+1)}{2}\\
=\frac{1}{2}(\sum_{i=1}^ni^2+\sum_{i=1}^ni)\\
=\frac{1}{2}(\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2})\\
=\frac{n(n+1)(n+2)}{6}
$$

易知，$T(n)=O(n^3)$（观察上式最高次项幂次）

##### 例3

:star:

~~~c
int i = 1;
while( i <= n ){
	i *= 2;
}
~~~

$$
i <= n\\2^x <= n\\
x <= log_2n\\
2^{f(n)} <= n\\
f(n) <= log_2n\\
取最大值f(n) = log_2n
$$

则$T(n) = O( log_2n)$

#### 3.时间复杂度

①最坏时间复杂度	②平均时间复杂度	③最好时间复杂度

- 一般考虑①②，②难算时仅考虑①

- 对于复杂的算法，可以把它分成几个容易估算的部分，然后利用加法法则和乘法法则，计算时间复杂度

  - 加法规则

    $T(n)=T_1(n)+T_2(n)=o(f(n))+o(g(n))=O(max(f(n),g(n)))$

  - 乘法规则

    $T(n)=T_1(n)×T_2(n)=o(f(n))×o(g(n))=O(f(n)×g(n))$

- 复杂度→由低到高→

| 常数阶 | 对数阶      | 线性阶 | 线性对数阶   | 平方阶   | 立方阶   | ...  | K次方阶  | 指数阶   |
| ------ | ----------- | ------ | ------------ | -------- | -------- | ---- | -------- | -------- |
| $O(1)$ | $O(log_2n)$ | $O(n)$ | $O(nlog_2n)$ | $O(n^2)$ | $O(n^3)$ |      | $O(n^k)$ | $O(2^n)$ |

#### 4.空间复杂度

记作$S(n)=O(f(n))$

例

~~~c
# 算法一
for( i = 0; i < n/2; i ++ ){
    t = a[i];
    a[i] = a[n-i-1];
    a[n-i-1] = t;
}

# 算法二
for( i = 0; i < n; i ++ ){
    b[i] = a[n-i-1];
}
for( i = 0; i< n; i ++ ){
    a[i] = b[i];
}
~~~

- 算法一原地工作，仅用一个变量的空间，故是一个常数阶$S(n)=O(1)$
- 算法二b[i]与个数n有关，为一次阶，$S(n)=O(n)$

算法一的空间复杂度低于算法二



### 三. 栈

#### 3.1 栈和队列的特点

- 栈：只能在最后一个上操作删除和插入，后进先出
- 队列：只能在最后插入新元素，只能删除最开始的元素，新进新出

#### 3.2 栈和队列的定义和特点

都不能随意访问元素

##### （1）栈

- stack，一种运算规则特殊的线性表
- 顺序栈和链栈都有，前者更常见
- 表尾称为栈顶Top($a_n$)，表头称为栈底Base($a_1$)
- 入栈(PUSH, x)，出栈(POP, y)

##### （2）队列

- queue，类似于排队的规则
- 顺序队和链队都有，前者更常见

- 队尾为$a_n$，队头为$a_1$
- 队头离开，对尾加入

#### 3.2 栈和队列的案例

- 进制转换
- 括号匹配
- 算符优先算法
- 舞伴问题

#### 3.3 栈的表示和操作的实现

- 利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址段。
  - top指针：指示栈顶元素在顺序栈中的位置（为了方便操作一般指向真正栈顶元素之上的地址）
  - base指针：指示栈底元素在顺序栈中的位置
  - stack_size：表示栈可使用的最大容量（最高一级即`stack_size - 1`）
- 空栈：base==top
  - 出栈前确认
  - 取栈顶元素前确认
- 栈满：top-base==stack_size
  - 进栈前确认



~~~c
typedef int Status;
typedef int ElemType;	//定义元素类型
typedef struct _stack{
    ElemType *base;
    ElemType *top;
    int stacksize;
}Stack;

#define OK 0
#define ERROR 1
#define STACKSIZE 100
#define STACKINCREMENT 10
~~~

##### （1）栈的初始化

~~~c
int main(){
	unsigned n, base;
	printf( "Please input a number to convert: " );
	scanf( "%u", &n );
	printf( "Please input a number as base: " );
	scanf( "%u", &base );
	BaseConvertion( n, base );
	return 0;
} 
~~~

- `if语句`判断栈内存分配是否成功，否则返回ERROR（1）
- `S.top = S.base`规定开始时top和base都指向栈的最下端
- `S.stacksize = STACKSIZE`将最开始定义的栈大小在初始化时赋给结构体中的`stacksize`

##### （2）元素进栈

~~~c
Status Push( Stack *S, ElemType e ){
	if( S -> top - S -> base > S -> stacksize ){
		S -> base = ( ElemType* )realloc( S -> base, ( S -> stacksize + STACKINCREMENT ) * sizeof( ElemType ) );
		if( !S -> base ){
			return ERROR;
		}
		S -> top = S -> base + S -> stacksize;
		S -> stacksize += STACKINCREMENT;
	}
	*( S -> top ) = e;
	S -> top ++ ;
	return OK;
}
~~~

- `realloc`语法: `（ 数据类型* ）realloc（ 要改变内存大小的指针名， 新的大小 ）`
- `S.top - S.base > Stacksize`判断是否满栈，满栈的条件是==，如果大于则重新分配内存
  - `if语句`判断栈内存分配是否成功，否则返回ERROR（1）

- `S.top = e` 把新元素放在栈顶
- `S.top ++` 栈顶指针上移一位指向新的栈顶
- ==容易忘记重新定义栈顶和更新容量==

##### （3）元素出栈

~~~c
Status Pop( Stack *S, ElemType *e ){
	if( S -> top == S -> base ){
		return ERROR;
	}
	S -> top --;
	*e = *( S -> top );
	return OK;
}
~~~

- `S.top - S.base > Stacksize`判断是否为空栈，如果是则不能继续有元素出栈

- `S -> top --` 起到了移除顶端的作用，`*e = *( S -> top )`缓存去除的值

##### （4）取栈顶元素

~~~c
Status GetTopElement( Stack *S， ElemType *e ){
	if( S -> top == S -> base ){	//避免空栈
        return ERROR;
    }
    *e = *( S -> top - 1 );		//e存储栈顶元素
    return OK;
} 
~~~

##### （5）清空栈

- 栈顶指向栈底即可

~~~c
Status ClearStack( Stack *S ){
    S -> top = S -> base;
    return OK;
}
~~~

##### （6）销毁栈

1. 释放栈底指针（栈的存储空间是靠栈底指针分配得到的）
2. 把栈底指针和栈顶指针赋值为NULL
3. 栈容量归零

~~~c
Status DestroyStack( Stack *S ){
	free( S -> base );
	S -> top = NULL;
	S -> base = NULL;
	S -> stacksize = 0;
	return OK;
}
~~~

##### （7）实现案例

**进制转化**

1. 初始化栈
2. （n>0）n对base求余
3. 余数入栈
4. 更新n为n/base，转到2
5. （栈非空）栈顶元素出栈，输出
6. 循环5直到不满足条件

~~~c
void BaseConvertion( unsigned n, unsigned base ){
	Stack S;
	initStack( &S );
	int k, e;
	while( n > 0 ){
		k = n % base;
		Push( &S, k );
		n /= base;
	}
	while( S.top != S.base ){
		Pop( &S, &e );
		char format[3] = { '%' };
		if( base == 16 ){
			format[1] = 'x';
		} else{
			format[1] = 'u';
		}
		printf( format, e );
	}
	free( S.base );
}
~~~

> **When `printf(format, e)` is called, it substitutes the `%` in the `format` array with either `'x'` or `'u'` depending on the value of `base`, and then prints the popped element `e` according to the specified format. So, if `base` is 16, `printf` will interpret the format specifier as hexadecimal (`%x`), and if `base` is any other value, it will interpret it as unsigned decimal (`%u`).**

##### （8）错误总结

- *S时用`->`， &S或S在函数定义了的时候直接用`.`

- 函参为*X时，传入参数需是地址&

- `scanf`时要&n

- 要给传入的指针所指数赋值时，指针都需要`*( )`以表示是指针所指的值

  - > **In the line `*(S->top) = e;`, `S->top` is a pointer to the top of the stack, and `e` is the element you want to push onto the stack.**
    >
    > **The expression `*(S->top)` dereferences the pointer `S->top`, which means it accesses the value that `S->top` points to. In this case, `S->top` points to the memory location where the next element in the stack should be stored.**
    >
    > **By assigning `e` to `*(S->top)`, you are effectively storing the value of `e` in the memory location pointed to by `S->top`, which effectively pushes the element `e` onto the stack.**
    >
    > **So, the use of the pointer is necessary to access the memory location where the new element should be stored, enabling you to modify the contents of that memory location.**