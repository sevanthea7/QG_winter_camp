# 数据结构

## 一.绪论

### 1.1 数据结构研究

- 数据结构是一门研究非数值计算的程序设计中计算机的操作对象以及它们之间的关系和操作的学科
  - 即“非数值计算”的程序设计问题
  - 非数值计算问题的数学模型不是数学方程，而是表、树、图之类的具有逻辑关系的数据

### 1.2 基本概念和术语

* 数据
  * 数值型数据：可进行算术运算
  * 非数值型数据：不能算数运算，主要是表、图之类的

- 数据元素

  - 数据的基本单位
  - 如在一张学生表中的某一行，包括学生的姓名、学号、性别（这些都是数据项），看作一个，即一个数据元素（也叫元素、记录、结点、顶点）
  - 数据项组成数据元素，数据元素组成数据

- 数据对象

  - 性质相同的数据元素的集合，是数据的一个子集
    - 如整数的数据对象$N=\{0, \pm1,\pm2,...\}$

- 数据结构：数据元素相互之间的关系（是带结构的数据元素的集合，元素之间不是孤立的而是存在某种关系）

  - 逻辑结构

    ​     **划分方式1**

    - 线性结构：有且仅有一个开始结点和一个终端结点
      - 线性表、栈、队列、串
    - 非线性结构
      - 图、树

    ​     **划分方式2**

    * 集合结构
    * 线性结构：一对一
    * 树形结构：一对多
    * 网状结构

  - 物理结构：数据元素在计算机存储器中的结构

    - 顺序存储结构：用一组**连续的存储单元**依次存储数据元素；如C语言中的数组实现顺序存储结，存储顺序与元素顺序相同，
    - 链接存储结构：用一组**任意的存储单元**存储数据元素；之间的逻辑关系用指针来表示，如C语言中的指针实现链式存储结构

  - 数据运算

- 数据类型

- 抽象数据类型

### 1.4 算法复杂度

#### 1.计算方法

**算法运行时间=一个简单操作所需的时间×简单操作次数**

**算法运行时间=Σ每条语句的执行次数×该语句执行一次所需的时间**

- 每条语句的执行次数：语句频度
- 该语句执行一次所需的时间：随机器而已的固定时间，看作单位时间

算法运行时间=Σ每条语句频度×单位时间

消耗时间记为$T(n)$

- 为了便于比较不同算法的时间效率，我们仅比较他们的数量级
- 如$T_1(n)=10n^2, T_2(n)=5n^3$，数量级越大的越不好，所以$T_1(n)$更好

$f(n)$是$T(n)$的数量级函数，$O(f(n))$是算法的时间复杂度

例：如一个算法的时间复杂度为$T(n)=2n^3+3n^2+2n+1$，n无限大时$T(n)$与$n^3$是同数量级，引入O记号，则可记作$T(n)=O(n^3)$

- 只用看幂次最高的项幂次是多少，所以找到算法中执行次数最多的语句执行了多少次即可，找执行循环嵌套最深的

- 要注意，循环体的执行次数会比循环体内语句的执行次数多一次

#### 2.示例

##### 例1

N×N的矩阵相乘

~~~c
for( i = 1, i <= n; i ++ ){
	for( j = 1; j <= n; j ++ ){
		c[i][j] = 0;
		for( k = 1; k <= n; k ++ ){
			c[i][j] = c[i][j] + a[i][k]*b[k][j];
		}
	}
}
~~~

$$
T(n) = \sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n1\\=\sum_{i=1}^n\sum_{j=1}^nn\\=\sum_{i=1}^nn^2=n^3\\=o(n^3)
$$

##### 例2

~~~c
for( i = 1; i <= n; i ++ ){
	for( j = 1; j <= n; j ++ ){
		for( k = 1; k <= n; k ++ ){
			x += 1;
		}
	}
}
~~~

$$
语句频度=\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j1\\
=\sum_{i=1}^n\sum_{j=1}^ij\\
=\sum_{i=1}^n\frac{i(i+1)}{2}\\
=\frac{1}{2}(\sum_{i=1}^ni^2+\sum_{i=1}^ni)\\
=\frac{1}{2}(\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2})\\
=\frac{n(n+1)(n+2)}{6}
$$

易知，$T(n)=O(n^3)$（观察上式最高次项幂次）

##### 例3

:star:

~~~c
int i = 1;
while( i <= n ){
	i *= 2;
}
~~~

$$
i <= n\\2^x <= n\\
x <= log_2n\\
2^{f(n)} <= n\\
f(n) <= log_2n\\
取最大值f(n) = log_2n
$$

则$T(n) = O( log_2n)$

#### 3.时间复杂度

①最坏时间复杂度	②平均时间复杂度	③最好时间复杂度

- 一般考虑①②，②难算时仅考虑①

- 对于复杂的算法，可以把它分成几个容易估算的部分，然后利用加法法则和乘法法则，计算时间复杂度

  - 加法规则

    $T(n)=T_1(n)+T_2(n)=o(f(n))+o(g(n))=O(max(f(n),g(n)))$

  - 乘法规则

    $T(n)=T_1(n)×T_2(n)=o(f(n))×o(g(n))=O(f(n)×g(n))$

- 复杂度→由低到高→

| 常数阶 | 对数阶      | 线性阶 | 线性对数阶   | 平方阶   | 立方阶   | ...  | K次方阶  | 指数阶   |
| ------ | ----------- | ------ | ------------ | -------- | -------- | ---- | -------- | -------- |
| $O(1)$ | $O(log_2n)$ | $O(n)$ | $O(nlog_2n)$ | $O(n^2)$ | $O(n^3)$ |      | $O(n^k)$ | $O(2^n)$ |

#### 4.空间复杂度

记作$S(n)=O(f(n))$

例

~~~c
# 算法一
for( i = 0; i < n/2; i ++ ){
    t = a[i];
    a[i] = a[n-i-1];
    a[n-i-1] = t;
}

# 算法二
for( i = 0; i < n; i ++ ){
    b[i] = a[n-i-1];
}
for( i = 0; i< n; i ++ ){
    a[i] = b[i];
}
~~~

- 算法一原地工作，仅用一个变量的空间，故是一个常数阶$S(n)=O(1)$
- 算法二b[i]与个数n有关，为一次阶，$S(n)=O(n)$

算法一的空间复杂度低于算法二