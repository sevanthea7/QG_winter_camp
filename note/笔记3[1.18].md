## 1月18日(python学习)

### 一.学习内容

* 条件控制以及循环控制
* 推导式
* 错误和异常捕获
* map，lambda，filter函数的使用

### 二.学习笔记

#### 1.条件控制以及循环控制

==与c语言用法基本一致，需注意缩进==

##### (1)条件控制

###### ①单分支选择结构

~~~
num = input("please enter a number:")
# 此时输入的内容是字符串，所以需要先将它转换成数字再进行比较
if int(num) < 10:
	print(str(num)+"<10")	# 注意缩进
# 输入时如果与字符串拼接则需要重新把它换回字符串
~~~

###### ②双分支选择结构

~~~
num = input("please enter a number which is under 10:")
if int(num) < 10:
	print(num)
else:
	print("Error")
	
# 更简介的书写方式
print(num if int(num)<10 else "Error ")
~~~

###### ③多分支选择结构

~~~
score = int(input("enter your score: "))  # 在一开始就转成整型变量
grade = ''
if score < 60:
	grade = 'unqualified'
elif score < 80:
	grade = 'qualified'
elif score < 90:
	grade = 'good'
elif score <= 100:
	grade = 'excellent'
print("your score is {0}，your grade is {1}".format(score, grade))
~~~

###### ④选择结构的嵌套

* 逐个规定

~~~
score = int(input("please enter your score:"))
grade = ''
if score > 100 or score < 0:
	print("error")
elif score >= 90:
	grade = 'A'
elif score >= 80:
	grade = 'B'
elif score >= 70:
	grade = 'C'
elid score >= 60:
	grade = 'D'
else:
	grade = 'E'
print("your score is {0}, your grade is {1}".format(score, grade))
~~~

* 字符串规定

~~~
score = int(input("please enter your score:"))
grade = 'ABCDE'
num = 0
if score > 100 or score < 0:
    print("error")
else:
    num = score//10
    if num < 6:
        num = 5
    print("your score is {0}, your grade is {1}".format(score, grade[9-num]))
~~~

##### (2)循环控制

###### ①while循环结构

* 循环打印

~~~
a = 0
while a < 10:
	print(a+1)
	a += 1 
~~~

* 循环累加某范围内的数字和

~~~
num = 1
sum_total = 0
sum_even = 0
sum_odd = 0

while num <= 10:
    sum_total += num
    if num % 2 == 0:
        sum_even += num
    else:
        sum_odd += num
    num += 1

print("total sum is: " + str(sum_total))
print("even sum is: " + str(sum_even))
print("odd sum is: " + str(sum_odd))
~~~

###### ②for循环结构

* 遍历元组或列表

  x 可以叫任意名字，只是用来暂时存储的变量

  ~~~
  for x in (20, 30, 40):
      print(x)
  for x in ‘abcde:
      print(x) 
  ~~~

* 遍历字典

  ~~~
  info = {'name': 'xxx', 'age': 18, 'gender': 'M'}
  for x in info:				# 遍历键
      print(x)
  for x in info.keys():		# 遍历键
      print(x)
  for x in info.values():		# 遍历值
      print(x)
  for x in info.items():		# 遍历键值对
      print(x)
  ~~~

* 遍历range对象

  * **range(start, end, step)**
    * 生成数字不包含end
    * 没有规定start则默认为0
    * 没有规定step则默认为1

  ~~~
  for i in range(10):
      print(i, end=' ')
  print()
  for i in range(3, 10):
      print(i, end=' ')
  print()
  for i in range(3, 10, 2):
      print(i, end=' ')
  ~~~

  打印结果：

  0 1 2 3 4 5 6 7 8 9 
  3 4 5 6 7 8 9 
  3 5 7 9 
  * 循环累加某范围内的数字和

    ~~~
    sum_total = 0
    sum_even = 0
    sum_odd = 0
    
    for k in range(1, 11):
        sum_total += k
        if k % 2 == 0:
            sum_even += k
        else:
            sum_odd += k
    
    print("total sum is: " + str(sum_total))
    print("even sum is: " + str(sum_even))
    print("odd sum is: " + str(sum_odd))
    ~~~

###### ③嵌套循环

* **注意缩进**

* 循环打印数字

~~~
for i in range(5):
    for j in range(5):
        print(j, end=' ')
    print()
~~~

* 打印九九乘法表

~~~
for i in range(1, 10):
    for j in range(1, i+1):
        print("{0} * {1} = {2}".format(j, i, (i*j)), end='\t')
    print()
~~~

* 打印符合条件的字典内容

~~~
r1 = dict(name='xxx', age=18, gender='M')
r2 = dict(name='yyy', age=21, gender='F')
r3 = dict(name='zzz', age=22, gender='M')
tb = [r1, r2, r3]			# 字典合成表格

for x in tb:
    if x.get('age') >= 19:	# 打印满足age不小于19的字典
        print(x)
~~~

###### ④break与continue

* 二者与c语言中的用法基本一致

* break

  ~~~
  while True:
      a = input("enter 'x'or 'X to exit the programme: ")
      if a.upper() == 'X':
          print("ending")
          break			# 如果输入了x或X则结束输入
      else:
          print("continuing")
  ~~~

* continue

  ~~~
  eenum = 0			# 记录员工数量，每增加一人，该变量加一
  slrysum = 0			# 记录收入总量，每增加一个，加在总和上
  slry = []			# 记录输入的收入，存储在列表中
  while True:
      s = input("enter the salary for the employee( enter 'x' or 'X' to end ): ")
      if s.upper() == 'X':
          print("ending")
          break		# 如果输入了x或X则结束输入
      elif float(s) < 0:
          print("error, please reenter positive number")
          continue	# continue后的内容在本轮循环不会继续运行
      print("enter success")
      eenum += 1
      slry.append(float(s))
      slrysum += float(s)
  
  print("there are " + str(eenum) + " employees")
  print("the salary entered are", slry)
  print('the total amount of salary is: ' + str(slrysum))
  print('the average salary is: '+str(slrysum/float(eenum))) # 注意数字和字符串的多次转换
  ~~~

  ==增添列表元素时能用append就不要用’+‘ ！==

###### ⑤while和for循环中的else语句

* while和for循环可选择性附带一个else语句
* 如果循环没有被break结束，则执行附带的else语句，否则不执行

~~~
slrysum = 0
slry = []
for i in range(3):
	s = input("enter salary('x' or 'X' for ending)")
	if s.upper() == 'X':
		print('ending')
		break
	elif float(s) < 0:
		print('error, please reenter')
		continue
	slry.append(float(s))
    slrysum += float(s)
else:
	print('you have the 3 employees' salary)
~~~

即输入了三次才会显示最后一行“已录入三位员工的收入”，如果中途通过x退出输入则会经过break语句，此时输入次数不满三次，也不会显示最后一行内容。

#### 2.推导式

##### (1)列表推导式

* 基本语法

  ~~~
  [表达式 for item in 可迭代对象]
  [表达式 for item in 可迭代对象 if 条件判断]
  ~~~

  * item可以为任意存储变量，表达式需关于item

  * 可迭代对象一般用range()对象，如加上了if判断，则选择处理迭代器出来的新数

* 示例

  ~~~
  [x for x in range(1, 5)]	# [1, 2, 3, 4]
  [x*2 for x in range(1, 5)]``# [2, 4, 6, 8]
  [x*2 for x in range(1, 20) if x%5==0]	#[10, 20, 30]
  [a for a in 'abc']			# [a, b, c]
  
  # 两个循环，用zip()并行迭代
  cells = [(row, col) for row, col in zip(range(1, 3), range(101,103))]
  for cell in cells:
  	print(cell, end=' ')	# (1, 101) (2, 102) 
	
  values = ['a', 'b', 'c', 'd']
  order = {odr: value for odr, value in zip(range(1, 5), values)}
  {1: 'a', 2: 'b', 3: 'c', 4: 'd'}
  ~~~

##### (2)字典推导式

* 统计文本中字符出现的次数

  ~~~
  text = 'im on a hellevator'
  char_count = {c: text.count(c) for c in text}
  print(char_count)	# {'i': 1, 'm': 1, ' ': 3, 'o': 2, 'n': 1, 'a': 2, 'h': 1, 'e': 2, 'l': 2, 'v': 1, 't': 1, 'r': 1}
  ~~~

  **字典中的键是唯一的，出现相同的键时后者会覆盖前者的值，所以不会出现同一个键值对多次出现**

##### (3)集合推导式

与列表推导式类似，只是没有顺序

* 基本语法

  ~~~
  {表达式 for item in 可迭代对象}
  {表达式 for item in 可迭代对象 if 条件判断}
  ~~~

* 示例

  ~~~
  {x * 2 for x in range(1, 100) if x % 9 == 0}
  {162, 36, 198, 72, 108, 144, 18, 180, 54, 90, 126}
  ~~~

##### (4)生成器推导式

* 不直接生成元组，元组没有推导式
* 一个生成器只能运行一次，第一次迭代可以得到数据，第二次就没有了

~~~
n = (x for x in range(1, 20) if x % 9 == 0)
for x in n:
    print(x, end=' ')	# 9 18
for x in n:
    print(x, end=' ')	# 无打印内容
~~~

#### 3.错误和异常捕获

##### (1) 错误和异常

###### ①语法错误

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401181146229.png)

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401181146228.png)

* ^ 处为语法出现错误的位置
* 异常类型为：SyntaxError

###### ②逻辑错误

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401181149112.png)

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401181149111.png)

* 此处代码语法正确，但是运行后产生逻辑错误（for循环不支持遍历整型数据）
* 错误类型为：TypeError

###### ③错误类型总结

| 类名              | 类名                                       |
| ----------------- | ------------------------------------------ |
| SyntaxError       | 发生语法错误时引发                         |
| FileNotFoundError | 未找到指定文件或目录时引发                 |
| NameError         | 找不到指定名称的变量时引发                 |
| ZeroDivisionError | 除数为 0 时引发                            |
| IndexError        | 当使用超出列表范围的索引时引发             |
| KeyError          | 当使用字典不存在的键时引发                 |
| AttributeError    | 当尝试访问未知对象属性时引发               |
| TypeError         | 当试图在使用 a 类型的场合使用 b 类型时引发 |

##### (2)异常捕获

###### ①try...except语句

* 语法

  ~~~
  try:
  	可能会出错的代码
  except 异常类型:
  	错误处理语句
  ~~~

  * 先执行try与except之间可能出错的代码
  * 如果这部分代码没有出现异常，则不执行except后的语句
  * 如果try的子句出现异常，则不继续执行try后剩下的代码，直接执行except的语句

* 示例

  ~~~
  try:
  	for i in 2:
  		print(i)
  except:
  	print('int类型不支持迭代操作')
  ~~~

  运行结果：打印 'int类型不支持迭代操作'

###### ②捕获异常信息

在except子句中使用关键词as获取系统反馈的异常的具体信息

* 捕获单个异常

  ~~~
  try:
  	for i in 2:
  		print(i)
  except TypeError as e:
  	print(f'异常原因: {e}')
  ~~~

  * 异常信息为e（可定义为任意变量名），如果程序异常的原因符合规定的异常原因，则正常运行至except输出异常原因

  * 若不符合程序仍然无法正常运行

  此处运行结果：异常原因： ‘int’ object is not iterable

* 捕获多个异常

  将多个具体的异常类组成元组放在except语句后

  ~~~
  try:
  	print(count)
  	list = ['ab', 'cd']
  	print(list[3])
  except (NameError, IndexError) as error:
  	print(f'异常原因: {error}')
  	
  也可写作：
  except NameError as error:
  	print(f'异常原因: {error}')
  except IndexError as error:
  	print(f'异常原因: {error}')	
  ~~~

  * 错误1：要打印的变量count没有定义	----->	NameError

    错误2：list只有2个元素，但是打印访问的时第3个元素	----->	IndexError

  * 但是这两种情况均只打印第一种，因为异常在print(count)处就被捕获，所以运行不到第二个错误

* 捕获所有异常

  * 指定异常类为Exception类（是常见异常类的父类，所以可以指代所有常见的异常）

  ~~~
  try:
  	print(count)
  	list = ['ab', 'cd']
  	print(list[3])
  except Exception as error:
  	print(f'异常原因: {error}')
  ~~~

  此时也只会打印第一个错误的异常原因，但不会出现因为异常原因判断错误而出现的程序崩溃问题

  * 省略异常原因类

  ~~~
  try:
  	print(count)
  	list = ['ab', 'cd']
  	print(list[3])
  except：
  	print('error')
  ~~~

  此时运行只要出现异常就会打印'error'，但是不能得知错误的原因是什么
  * else语句类

  ~~~
  try:
  	可能出错的语句
  except:
  	出错后执行的语句
  else:
  	未出错时执行的语句
  ~~~

  * finally语句类

  ~~~
  try:
  	可能出错的语句
  except:
  	出错后执行的语句
  finally:
  	无论是否出错都会执行的语句
  ~~~

  处理文件时需要在操作完关闭文件，所以一般会在finally部分关闭文件，因为finally一定会被执行

  ~~~
  try:
  	file = open('error.txt', 'r')
  	file.write('error')
  except Exception as error:
  	print('failed', error)
  finally:
  	file.close()
  	print('file closed')
  ~~~

#### 4.map，lambda，filter函数的使用

##### (1)自定义函数

###### ①定义与调用

```
def 函数名 ([参数列表]) :
	函数内容语句
```

e.g.:

```
def add (a, b, c) :	# 定义
	sum = a + b + c
	print('sum is' + str(sum))
	return sum
	
add(10, 20, 30)		# 调用
x = add
y = x				# 此时x和y都相当于add，使用方法相同（赋予功能时函数不带小括号）
x(10, 20, 30)		# 相当于add，正常使用
y(10, 20, 30)
```

###### ②局部变量和全局变量

* 全局变量
  * 应尽量避免全局变量的使用
  * 要在函数内改变全局变量的值，要用global声明
* 局部变量：在函数体中声明的变量
  * 如果局部变量与全局变量重名，则在函数内使用重名的局部变量

~~~
a = 10

def f():
	b = 3
	global a
	a = 5
	print(locals())		# 打印全部局部变量
	print(globals())	# 打印全部全局变量
	
f()
print(a)
~~~

打印结果：

{'b': 3}
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x0000020FBE0DD4F0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'D:\\【Worksheet6】QG\\QG_winter_camp\\code\\python_learning\\w1.19.py', '__cached__': None, 'add': <function add at 0x0000020FBDF8A2A0>, =='k': 5==, 'f': <function f at 0x0000020FBE0859E0>, 'x': <function add at 0x0000020FBDF8A2A0>, 'y': <function add at 0x0000020FBDF8A2A0>}
5

##### (2)map()函数

* 把可迭代对象中的数据经过函数处理之后存储
* 存储的时候采用list()进行存储，返回的是一个集合

###### ①语法

**map(函数，一个或多个可迭代的序列)**

###### ②示例

~~~
def square(x):
    return x ** 2

print(list(map(square,[1,2,3,4,5])))
~~~

打印结果：[1, 4, 9, 16, 25]

* **类似于可以把一串数一块塞进函数进行运算得出一串新的数**

##### (3)filter()函数

* 对数据进行筛选和过滤

###### ①语法

**filter(函数，可迭代对象)**

###### ②示例

~~~
import math
def is_sqr(x):
	return math.sqrt(x) % 1 == 0
	
list_show = filter(is_sqr, range(1, 101))
print(list(list_show))
~~~

打印结果：[1,  4,  9,  16,  25,  36,  49,  64,  81,  100]

即返回结果为True的数值才会被记录

##### (4)lambda函数

* **临时定义临时使用，功能简单**
* 可以作为参数传入map，filter之类的函数

###### ①语法

 **lambda argument_list: expression**

* argument_list和expression由用户自定义

* argument_list：参数列表
* expression：参数的表达式

###### ②特性

* 匿名，lambda函数没有名字

* 有输入和输出，输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。

* 功能简单：expression是单行的，只能完成非常简单的功能

* 示例

  ~~~
  lambda x, y: x*y		# 函数输入是x和y，输出是它们的积x*y
  lambda:None				# 函数没有输入参数，输出是None
  lambda *args: sum(args)	# 输入是任意个数的参数，输出是它们的和
  lambda **kwargs: 1		# 输入是任意键值对参数，输出是1
  ~~~

~~~
f = lambda a, b, c: a+b+c

print(f(1, 2, 3))
g = [lambda a: a+2, lambda b: b*3, lambda c: c*4]
print(g[0](1), g[1](2), g[2](3))			# 需要单个单个赋值
~~~

打印结果：

6
3 6 12