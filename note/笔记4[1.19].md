## 1月19日(python学习)

### 一.学习内容

* 面向对象
  * 类与实例化 类变量以及方法 私有变量和私有方法 封装 继承 多态

### 二.学习笔记

#### 1.类与实例化

##### (1)类

类将行为和状态打包在一起，如：

> 学生类
>
> ​	属性（静态数据）
>
> ​		id
>
> ​		年龄
>
> ​		姓名
>
> ​	方法（动态行为）
>
> ​		学习
>
> ​		踢球
>

* 示例
  * `__init__()`的第一个参数固定，必须为self
  * def `__init__`就是构造海曙来初始化实例对象的属性
  * 语法：类名(参数列表) 
    * 用于调用构造函数
    * 调用后会将创建好的对象返回给相应的变量（如下方的s1）

~~~
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def say_score(self):
        print('{0}\'s score is {1}'.format(self.name, self.score))


s1 = Student('aaa', 11)
print(s1.name, s1.score)
s1.say_score()			# 调用类中的函数，打印的是刚刚传入的参数'aaa'和11
~~~

##### (2)类的实例化

###### ①实例属性

* 在 `__init__()`方法中的一般定义方法

  ~~~
  self.实例属性名 = 初始值
  ~~~

* 在本类的其他实例方法中，也是通过self进行访问

  ~~~
  self.实例属性名
  ~~~

* 访问实例对象

  * 变量名 = 类名(需传入的参数)

  * 变量名.实例属性名 = 值
    * 可以给已有的属性赋值
    * 也可以用于添加新的属性

###### ②实例方法

* 定义方法

  ~~~
  def 方法名 (self[, 形参列表]):
  
  	函数体
  ~~~

* 调用格式

  ~~~
  对象.方法名([实参列表])
  ~~~

* 要点
  * 定义实例方法时，第一个参数必须为self（当前的实例对象）
  * 调用实例方法时，不需要也不能给self传参

###### ③其他操作

* dir(obj) ：可以获得对象的所有属性、方法
* `obj. __dict__`：对象的属性字典
* pass ：空语句
* isinstance(对象, 类型) ：判断’对象‘是否是’指定类型‘

#### 2.类变量以及方法

==方法没有重载，不可重复==

##### (1)类对象

~~~
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def say_score(self):
        print('{0}\'s score is {1}'.format(self.name, self.score))


Stu = Student		# Stu和Student指向Student的类，可以用Stu来调用这个类
s1 = Stu('aaa', 12)
~~~

##### (2)类属性

* 类属性的定义方式
  * 调用时不要忘记开头要写类名

~~~
class 类名：
	类变量名 = 初始值
	

类名.类变量名		# 在类中或类的外面也可以通过这种方式来读写
~~~

~~~
class Student:
    school = 'GDUT'
    cnt = 0

    def __init__(self, name, score):
        self.name = name
        self.score = score
        Student.cnt += 1

    def say_score(self):
        print('my school is ' + Student.school)
        print('{0} "Student" content is created.'.format(Student.cnt))
        print('{0}\'s score is {1}'.format(self.name, self.score))
        
        
s1 = Student('aaa', 11)
s2 = Student('bbb', 12)
s1.say_score()
~~~

打印结果：

my school is GDUT
2 "Student" content is created.
aaa's score is 11

##### (3)类方法

~~~
@classmethod
def 类方法名(cls [, 形参列表])：
	方法体
~~~

* @classmethod必须位于方法上面一行
* 第一个cls是必须的，它指的是“类对象本身”
* 调用方式和实例方法一致，也不需要和能够给cls传参
* 不可以在类方法中访问实例属性和实例方法，只能用用类变量

##### (4)静态方法

* 与定义普通函数没有区别，只是放在类的空间里，调用需要“类调用”
* 不可以在类方法中访问实例属性和实例方法，只能用用类变量

~~~
class School:
    school = 'GDUT'

    def __init__(self, name):
        self.name = name

    @classmethod
    def print_school_name(cls):
        print('my school is ' + cls.school)

    @staticmethod
    def add(a, b):
        print('{0} + {1} = {2}'.format(a, b, a + b))
        return a+b


School.print_school_name()
School.add(1, 10)
~~~

打印结果：

~~~
my school is GDUT
1 + 10 = 11
~~~

==在类方法和静态方法中调用self的内容会报错==

##### (5)del、call和str

###### ①`__del__()`方法

~~~
class Person:
	def __del__(self):
		print('销毁对象：{0}'.format(self))
		
		
p1 = Person()
p2 = Person()
# del p2
print("end")
~~~

该程序会创建两个`Person`对象，然后打印"end"。程序退出时，Python的垃圾回收机制会自动销毁这两个对象，并调用它们的`__del__()`方法。这会导致以下输出：

```
end
销毁对象：<__main__.Person object at 0x...>
# 销毁对象：<__main__.Person object at 0x...>
```

* `__del__()`方法的执行时间是不确定的，因此无法确定它们何时被调用

###### ②`__call__()`方法

使实例对象可以像调用普通函数那样，以`对象名()`的形式使用

~~~
def f1():
	print('f1')
	

f1()

class Test:
	def __call__(self, age, salary):
		print('call')
		print('age:{0} salary:{1}'.format(age, salary))
		

c = Test()
c(18, 10000)
~~~

###### ③`__str__()`方法

~~~
class Person:
...

	def __str__(self):
		print('strmethod')
		return 'name is'+self.name


p = Person('xxx', 19)
print(p)		# strmethod（方法内的打印内容）
s = str(p)		# strmethod
print(s)		# name is xxx（）返回内容
~~~

相当于把对象转换成一个字符串

##### (6)方法的动态性

~~~
class Person:
	def work(self):
		print('work')

def play_game(self):
	print('play game')

def work2(self):
	print('workwork')
	
Person.play = play_game			# 在Person里添加了新的函数play
Person.work = work2				# work替换成了work2

p = Person()
p.play()
p.work()
~~~

#### 3.私有变量和私有方法

* 类内部可以访问私有属性（方法）
* 类外部不能直接访问私有属性（方法）
* 两个下划线开头的属性使私有的，其他为公共
* 类外部要通过`_类名__私有属性（方法）名`访问私有属性（方法）

~~~
class TestPri:
    __school = 'GDUT'

    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def say_info(self):
        print('my age is', self.__age)		# 在类内访问私有变量
        print('my school is', self.__school)

    def __primeth(self):
        print('assess PriMeth')


print(TestPri._TestPri__school)				# 访问私有变量
m = TestPri('xxx', 18)
m._TestPri__primeth()						# 访问私有方法
m.say_info()
~~~

* 运行时，`__school`会被转换成`_TestPri__school`

#### 4.封装、继承与多态

##### (1)封装

* 隐藏

##### (2)继承

==alt+7查看继承结构==

###### ①使用方法

* 让子类具有父类的特性，提高了代码的重用性
* 语法

~~~
class 子类类名(父类1[, 父类2, ...]):
	类体
~~~

* 示例

~~~
class NewPerson(Person):
    def __init__(self, name, age, score):
        Person.__init__(self, name, age)
        print('create new person info')
        self.score = score

    def say_score(self):
        print('{0} score is {1}'.format(self.name, self.score))

    def say_age(self):					# 与父类名字相同的方法，会重写父类，即调用时为子类方法
        print('my age is', self.age)


s1 = NewPerson('xxx', 18, 90)
s1.say_age()
s1.say_score()
~~~

打印结果：

~~~
create person info
create new person info
my age is 18
xxx score is 90
~~~

###### ②层次结构查看

* 继承的层次结构可以用mro()

~~~
class A: pass
class B(A): pass
class C(B): pass

print(C.mro())
~~~

打印结果：

~~~
[<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]
~~~

###### ③组合

~~~
class CPU:
    def calculation(self):
        print('CPU calculating')


class Screen:
    def display(self):
        print('Screen displaying')


class Phone:
    def __init__(self, cpu, screen):
        self.cpu = cpu
        self.screen = screen


c = CPU()
s = Screen()
p = Phone(c, s)					# 传入两个对象，进行组合
p.cpu.calculation()				# 通过p中的实例对象来调用
p.screen.display()
~~~

打印结果：

~~~
CPU calculating
Screen displaying
~~~

##### (3)多态

* 同一个方法调用由于对象不同会产生不同的行为

* 两个必要条件
  * 继承
  * 方法重写

~~~
class WhoEats:
    def eat(self):
        print('I am eating')


class BY(WhoEats):
    def eat(self):						# 重写
        print('BY EATS MUTTON')

class Quokka(WhoEats):
    def eat(self):						# 重写
        print('QUOKKA EATS amkn')


def hungry(h):
    h.eat()		#传入不同的对象，调用不同的方法


hungry(BY())
hungry(Quokka())
~~~

打印结果：

~~~
BY EATS MUTTON
QUOKKA EATS amkn
~~~

