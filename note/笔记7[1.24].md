# numpy库学习(1月24日)

## 一.学习内容

* jupyter notebook的配置与使用
* numpy库学习
  * 基于列表构建矩阵
  * 特殊矩阵构建
  * 矩阵乘法
  * 矩阵广播机制
  * 矩阵转置
  * 矩阵的逆
  * 矩阵存取

## 二.学习笔记

### （一）jupyter notebook

#### 1.功能

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401241831231.jpg)

单元格状态可更改为使用markdown语言

#### 2.操作

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401242032868.png)

每一块代码都可以输出这一块代码的运行结果

### （二）numpy库学习

* 多用在大型、多维数组上执行数值运算

#### 1.构建

##### （1）创建数组

~~~
import numpy as np
t1 = np.array([1, 2, 3, 4, 5])
t2 = np.array(range(1, 6))
t3 = np.arange(1,6)
~~~

##### （2）数组类型和数据类型

* 上面t1, t2, t3输出的内容相同
* 生成数组类型(type)均为`numpy.ndarray`
* 生成数字类型(dtype)均为`int 64`

* ==np.arange([start, ]stop[, step], dtype=None)==  
  * 语法与range一致
  * 用于快速生成数组

~~~
# 规定数据类型
t1 = np.array([1, 2, 3, 4, 5], dtype='float64')
t2 = np.array(range(1, 6), dtype=bool)
# 调整数据类型
t3 = t2.astype('int64')
~~~

##### （3）小数位数

~~~
# 随机生成十个小数，存入t1
t1 = np.array([random.random() for i in range(10)])
# 对t1中的小数保留两位小数，存入t2
t2 = np.round(t7, 2)
~~~

##### （4）数组的形状

###### ①维度

~~~
t1 = np.array([1,2,3,4,5])
print(t1.shape)		# (5,)
t2 = np.array([1,2,3], [4,5,6])
print(t9.shape)		# (2,3)
~~~

* 三维数组

  ~~~
  t3 = np.array([ [[1,2,3],[4,5,6]], [[7,8,9],[10,11,12]] ])
  print(t3.shape)	# (2,2,3)
  ~~~

* 一维数组中输出元组中只有一个数，二维两个，三维三个

###### ②修改形状

~~~
t4 = np.arange(1,13)
t4 = reshape((3,4))
# t4 --> array([[1,2,3,4],
			 	[5,6,7,8]
				[9,10,11,12]])
t5 = np.arange(24).reshape((2,2,3))
t6 = t5.reshape((4,6))	# 改为二维
# 修改本身 t5 = t5.reshape((4,6))
t6 = t5.reshape((24,))	# 改为一维
t7 = t5.flatten()		# 改为一维，这个函数仅能改成一维
~~~

* 三维数组中（a, b, c），a表示数组的块数，b、c分别表示每一块中数组的行数和列数
* reshape函数有返回值，并不会修改原数组本身

##### （5）基于列表构建矩阵

`np.matrix(列表)`

~~~
m = np.matrix(t6)
~~~

##### （6）特殊矩阵的构建

###### ①循环矩阵

~~~
a = circulant([1,2,3])
print(a)
[[1 3 2]
 [2 1 3]
 [3 2 1]]
~~~

###### ②汉克尔矩阵

~~~
b = hankel([1,2,3,4], [0,7,7,8,9])
print(b)
[[1 2 3 4 7]
 [2 3 4 7 7]
 [3 4 7 7 8]
 [4 7 7 8 9]]
~~~

#### 2.计算

##### （1）数组和数的计算

~~~
t1 = np.arange(12)
print(t1+2)
print(t1*2)
print(t1/2)
~~~

* 这种计算方式是对数组中的每一个数进行计算操作

##### （2）数组和数组的计算

###### ①形状相同的数组

~~~
t2 = np.arange(24).reshape((4,6))
t3 = np.arrange(100,124).reshape((4,6))
print(t2+t3)
~~~

* 这种计算方式是两个数组中对应位置的数进行计算操作

###### ②形状不同的数组

**`广播机制`**

**Ⅰ二维数组**

**（Ⅰ）列数相同**

~~~
t4 = np.arange(6)
'''
t2 --> array([0,1,2,3,4,5],
			 [6,7,8,9,10,11],
			 [12,13,14,15,16,17],
			 [18,19,20,21,22,23])
t4 --> array([0,1,2,3,4,5])
'''
print(t2-t4)
print(t2*t4)
~~~

打印结果：

~~~
array([0,0,0,0,0,0],
	  [6,6,6,6,6,6],
      [12,12,12,12,12,12],
      [18,18,18,18,18,18])
array([0,1,4,9,16,25],
 	  [0,7,16,27,40,55],
	  [0,13,28,45,64,85],
 	  [0,19,40,63,88,115])
~~~

* 减法：t4只有一行，所以与t2的第一行相减，没有后面其余的行数字全部变为该行的第一个数字
* 乘法：每一行对应位置的数字进行计算

**（Ⅱ）行数相同**

~~~
t5 = np.arange(4).reshape((4,1))
'''
t5 --> array([0],
			 [1],
			 [2],
			 [3])
'''
print(t2-t5)
~~~

打印结果：

~~~
array([0,1,2,3,4,5],
	  [5,7,8,9,10,11],
	  [10,13,14,15,16,17],
	  [15,19,20,21,22,23])
array([0,0,0,0,0,0],
 	  [6,7,8,9,10,11],
	  [24,26,28,30,32,34],
	  [54,57,60,63,66,69])
~~~

* 减法：t5只有一列，相减时t2第一列的数字减去t5的内容，其余部分不变
* 乘法：每一列对应位置的数字进行计算

**两个形状不同或行数列数没有相同的数组无法进行计算，报错**

**Ⅱ三维数组**

* 一个三维数组与一个二维数组的后缘维度（即二维数组的行和列与三维数组的每一块的行和列）相同时，可以进行计算

* 一个三维数组与一个二维数组的后缘维度中有一个相同，另一个为1的时候，也可以进行计算
  * 如（3，3，2）可以与（3，2）、（3，1）或（1，2）进行计算，但不能与（2，3）进行

**（Ⅰ）轴**

* 二维数组

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401242030039.png)

如（2，5），0轴-->2，1轴-->5

* 三维数组
  * 0轴：块数所在的轴
  * 1轴：列数所在的轴
  * 2轴：行数所在的轴

![](https://sevanthea7.oss-cn-beijing.aliyuncs.com/QGworks/202401242027610.png)

如（1，2，5），0轴-->1，1轴-->2，2轴-->5

##### （3）矩阵乘法

~~~
t1 = np.arange(9).reshape(3,3)
t2 = np.arange(10,19).reshape(3,3)
m1 = np.matrix(t1)
m2 = np.matrix(t2)
print(m1)
print(m2)
print(m1*m2)
print(np.multiply(m1,m2))
~~~

打印结果：

~~~
[[0 1 2]
 [3 4 5]
 [6 7 8]]		--->m1
[[10 11 12]
 [13 14 15]
 [16 17 18]]	--->m2
[[ 45  48  51]
 [162 174 186]
 [279 300 321]]	--->m1, m2矩阵相乘
[[  0  11  24]
 [ 39  56  75]
 [ 96 119 144]]	--->m1, m2对应位置的数据相乘，类似数组相乘
~~~



#### 3.存取

##### Ⅰ存

从csv中读取数据

~~~
np.loadtxt(frame, dtype=np.float,delimiter=None, skiprows=0,usecols=Noe,unpack=False)
~~~

| 参数        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| **`frame`** | 文件、字符串或产生器                                         |
| `dtype`     | 数据类型，csv的字符串是什么读进来就是什么，默认为np.float    |
| `delimiter` | 分隔字符串，默认是空格                                       |
| `skiprows`  | 跳过开头的行数，可用于跳过表头                               |
| `usecols`   | 读取指定的列、索引、元组类型                                 |
| `unpack`    | True：读入属性将分别写入不同数组变量；False：读入数据只写入一个数组变量，默认为False |

~~~
import numpy as np

file_path = './xxx.csv'
t1 = np.loadtxt(file_path, delimiter=',')
~~~

* 规定文件路径到字符串里

* 按照loadtxt的语法进行书写

  * 如果文件内容都符合默认情况的话括号里只需要一个文件路径

  * 不符合的地方需要更改，如分隔字符如果是逗号的话就需要指定

##### Ⅱ取

###### （1）取行

①一行

```
t1 = np.arange(24).reshape(4,6)
m1 = np.matrix(t1)
print(t1[1])
print(m1[1])
```

~~~
[ 6  7  8  9 10 11]
[[ 6  7  8  9 10 11]]
~~~

②连续多行

```
print(t1[2:])
print(m1[2:])
```

~~~
[[12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[12 13 14 15 16 17]
 [18 19 20 21 22 23]]
~~~

③不连续多行

```
print(t1[[0,1,3]])
print(m1[[0,1,3]])
```

~~~
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [18 19 20 21 22 23]]
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [18 19 20 21 22 23]]
~~~

###### （2）取列

①一列

```
print(t1[:,1])
print(m1[:,1])
```

~~~
[ 1  7 13 19]
[[ 1]
 [ 7]
 [13]
 [19]]
~~~

②连续多列

```
print(t1[:,3:])
print(m1[:,3:])
```

~~~[[ 3  4  5]
 [ 9 10 11]
 [15 16 17]
 [21 22 23]]
[[ 3  4  5]
 [ 9 10 11]
 [15 16 17]
 [21 22 23]]
~~~

③不连续多列

```
print(t1[:,[0,3]])
print(m1[:,[0,3]])
```

~~~[[ 0  3]
 [ 6  9]
 [12 15]
 [18 21]]
[[ 0  3]
 [ 6  9]
 [12 15]
 [18 21]]
~~~

###### （3）取多行多列

例：取第1行到第3行，第2列到第4列

```
print(t1)
print(t1[0:3, 1:4])
```

打印结果：

```
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 1  2  3]
 [ 7  8  9]
 [13 14 15]]
[[ 1  2  3]
 [ 7  8  9]
 [13 14 15]]
```

取的是给出范围交叉部分

###### （4）取不相邻的多个点

```
c = t1[[0,2], [0,1]]
d = m1[[0,2], [0,1]]
print(t1)
print(c)
print(d)
```

打印结果：

```
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[ 0 13]
[[ 0 13]]
```

- 取的并不是（0，2）和（0，1）两个点，而是（0，0）和（2，1）

- 同理，`t1[[0,2,3], [0,1,1]]`取的是（0，0）、（2，1）、（3，1）三个点

#### 4.矩阵转置和逆

##### （1）转置

（矩阵和数组通用）

###### ①整个转置

`.transpose()`

`.T`

~~~
t1 = np.arange(12).reshape(3,4)
m = np.matrix(t1)
print(t1)
print(t1.transpose())
print(t1.T)
# print(m)
# print(m.transpose())
print(m.T)
~~~

打印结果：

~~~
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
 [[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
  [[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
~~~

###### ②指定转置的轴

数组：`.swapaxws(轴1，轴2)`

~~~
print(t1.swapaxes(0,1))
print(m.swapaxes(0,1))
~~~

打印结果：

~~~
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
 [[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
~~~

###### （2）逆

`.I`

~~~
t1 = np.arange(12).reshape(3,4)
m = np.matrix(t1)
print(m)
print(m.I)
~~~

打印结果：

~~~
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[-0.3375     -0.1         0.1375    ]
 [-0.13333333 -0.03333333  0.06666667]
 [ 0.07083333  0.03333333 -0.00416667]
 [ 0.275       0.1        -0.075     ]]
~~~

